:PROPERTIES:
:ID:       96307c66-a6f7-490d-8ba3-0f361cbe0e41
:END:
#+title: cmake
#+date: [2022-01-26 Wed 07:51]


Last Update <2021-08-26 Thu 05:20>

* Basic  Cmake Project
- cmake code must be stored in `CMakeLists.txt` at the project root
- cmake command ignore case sensitive

** Basic Cmake Project
#+begin_src cmake
cmake_minimum_required(VERSION 3.10)

# set the project name
project(Tutorial)

# add the executable
add_executable(Tutorial  tutorial.cxx)
#+end_src

in the example below `tutorial.cxx` is the source code of the project that will be executable.

** Adding a version number and configured header file
#+begin_src cmake
cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

#+end_src

You can also create configure file to pass the version number to the source code
#+begin_src cmake

# add configuration file for the project
# this will generate TutorialConfig.h at generated dir
configure_file(TutorialConfig.h.in TutorialConfig.h)

#+end_src

since the configure file will be written into the binary tree, we must add that directory to the list of
paths for include files.

#+begin_src cmake

# add generated project dir to include dir
target_include_directories(Tutorial PUBLIC "${PROJECT_BINARY_DIR}")

#+end_src
to use `Tutorial` in target include directory you must add `Tutorial` as executable first.

then create TutorialConfig.h.in in the source directory with the following
#+begin_src c

// the configured options and settings for Tutorial
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@

#+end_src

example to print version number at the source code
#+begin_src cpp

#include <iostream>
#include "TutorialConfig"

int main() {
  std::cout << "Version " << Tutorial_VERSION_MAJOR
                   << "." << Tutorial_VERSION_MINOR << std::endl;
  return 0;
}

#+end_src

another way to set version
#+begin_src cmake

PROJECT( Tutorial )
SET ( Tutorial_VERSION_MAJOR 0 )
SET ( Tutorial_VERSION_MINOR 1 )
SET ( Tutorial_VERSION_PATCH 0 )
SET ( Tutorial_VERSION ${Tutorial_VERSION_MAJOR}.${Tutorial_VERSION_MINOR}.${Tutorial_VERSION_PATCH} )
SET ( PROJECT_VERSION "${CPPCORE_VERSION}" )

#+end_src


** Specify the C++ Standard

add C++11 features to the cmake project
#+begin_src cmake

cmake_minimum_required(VERSION 3.10)

# set the project name and version
project(Tutorial VERSION 1.0)

# specify the c++ standard
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED true)

#+end_src

List of C++ standard
- 98 =  C++98
- 11 =  C++11
- 14 = C++14
- 17 = C++17      New in version 3.8.
- 20 = C++20     New in version 3.12.
- 23 = C++23     New in version 3.20.

** Build and Test
to generate a native build system from cmake and build the project
#+begin_src shell

  # create build directory and go to directory
  mkdir build
  cd build
 # and run cmake from there
  cmake ../
 # build project generated by cmake
 cmake --build .

#+end_src

another alternative command to generate and build project
#+begin_src shell

 # create build directory
 mkdir build
 # and run cmake from there
 cmake -S . -B build
 # build project generated by cmake
 cmake --build build

#+end_src

after generating project with cmake we can build it using our default build tools.
for example we generate the project for unix makefiles. you can simply just run make after cmake ../.
#+begin_src shell

 # create build directory and go to directory
 mkdir build
 cd build
 # and run cmake from there
 cmake ../
 # build project generated by cmake
 make

#+end_src

* Adding a library
to add library simpy add
#+begin_src cmake
 add_library(MathFunctions mysqrt.cxx)
#+end_src

to use library you need to add
#+begin_src cmake
 # add the MathFunctions library
 add_subdirectory(MathFunctions)

 # add the executable
 add_executable(Tutorial tutorial.cxx)

 target_link_libraries(Tutorial PUBLIC MathFunctions)

 # add the binary tree to the search path for include files
 # so that we will find TutorialConfig.h
 target_include_directories(Tutorial PUBLIC
                                                 "${PROJECT_BINARY_DIR}"
                                                 "${PROJECT_SOURCE}/MathFunctions"
                                                 )
#+end_src

you can also make the library optional to use by using conditional
#+begin_src cmake
option(USE_MYMATH "Use tutorial provided math implementation" ON)

# configure a header file to pass some of the CMake settings
# to the source code
configure_file(TutorialConfig.h.in TutorialConfig.h)

if (USE_MYMATH)
  add_subdirectory(MathFunctions)
  list(APPEND EXTRA_LIBS MathFunctions)
  list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/MathFunctions")
endif()

# add the executable
add_executable(Tutorial tutorial.cxx)

target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})

# add the binary tree to the search path for include files
# so that we will find TutorialConfig.h
target_include_directories(Tutorial PUBLIC
                                                 "${PROJECT_BINARY_DIR}"
                                                  ${EXTRA_INCLUDES} )
#+end_src

example source code using optional library
#+begin_src c
#ifdef USE_MYMATH
    #include "MathFunctions.h"
#endif

int main() {
#ifdef USE_MYMATH
  const double outputValue = mysqrt(inputValue);
#else
  const double outputValue = sqrt(inputValue);
#endif
}
#+end_src

one last thing is in the header input file 
#+begin_src c
/* file: TutorialConfig.h.in */
#cmakedefine USE_MYMATH
#+end_src
cmakedefine macro will be converted to `#define USE_MYMATH` if
 USE_MATH=ON otherwise `/* #undef USE_MATH */`

to set the value of cmake option just call cmake like this `cmake ../ -Doption_name=value`
or if you use cmake-gui the option will be appear at the cmake-gui option
#+begin_src shell
cmake ../ -DUSE_MYMATH=OFF
#+end_src

* Adding Usage Requirements for a library

to anybody that linking to MathFunctions needs to include the current source directory,
while MathFunctions itself doesn`t. So this can become an INTERFACE usage requirements.

add the following line to use INTERFACE.
#+begin_src cmake

target_include_directories(MathFunctions
                                                 INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
)

#+end_src

now we can remove safely remove our uses of EXTRA_INCLUDE variable from the top-level
CMakeLists.txt, here:

#+begin_src cmake

if (USE_MYMATH)
    add_subdirectory(MathFunctions)
    list(APPEND EXTRA_LIBS MathFunctions)
endif()

#+end_src

and here:
#+begin_src 
target_include_directories(Tutorial PUBLIC
                           "${PROJECT_BINARY_DIR}")
#+end_src

once this is done you can run cmake and the build it.

.-----------.------------------.----------------.
|           | Linked by target | Link interface |
:-----------+------------------+----------------:
| PUBLIC    |        X         |        X       |
:-----------+------------------+----------------:
| PRIVATE   |        X         |                |
:-----------+------------------+----------------:
| INTERFACE |                  |        X       |
'-----------'------------------'----------------'

Linked by target: libraries included in target sources (not a dependency for projects linking the library).
Link interface: libraries included in target public headers (dependencies for projects linking the library).

* Installing and Testing
** Installing
The install rule are fairly simple for MathFunctions we want to install the library and header file
for the application we want to install the executable and configured header.

So to the end of MathFunctions/CMakeLists.txt we add:
#+begin_src cmake

install(TARGETS MathFunctions DESTIONATION lib)
install(FILES MathFunctions.h DESTINATION include)

#+end_src

and to the end of the top-level CMakeLists.txt we add:
#+begin_src cmake

install(TARGETS Tutorial DESTINATION bin)
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h"
            DESTINATION include)

#+end_src

reconfigure project using cmake and then `cmake --install .` to install the library or you can
specify your installation directory by using cmake `--install . --prefix "/path/for/installation"`

** Testing
example enabling testing
#+begin_src cmake
enable_testing()

# does the application run?
add_test(NAME Runs COMMAND Tutorial 25)

# does the usage message work?
add_test(NAME Usage COMMAND Tutorial)
set_tests_properties(Usage
     PROPERTIES PASS_REGULAR_EXPRESSION 
)

# define a function to simplify adding tests
function(do_test target arg result)
    add_test(NAME Comp${arg} COMMAND ${target} ${arg})
    set_test_properties(Comp${arg} 
          PROPERTIES PASS_REGULAR_EXPRESSION ${result}
)
endfunction(do_test)

# do a bunch of result based tests
do_test(Tutorial 4 "4 is 2")
do_test(Tutorial 9 "9 is 3")
do_test(Tutorial 5 "5 is 2.236")
do_test(Tutorial 7 "7 is 2.645")
do_test(Tutorial 25 "25 is 5")
do_test(Tutorial -25 "-25 is [-nan|nan|0]")
do_test(Tutorial 0.0001 "0.0001 is 0.01")

#+end_src

rebuild the application and then run the ctest executable:
`ctest -N` and `ctest -VV`.
to run test in debug mode use `ctest -C Debug -VV`

* References
https://cmake.org/cmake/help/latest/guide/tutorial
https://stackoverflow.com/questions/26037954/cmake-target-link-libraries-interface-dependencies
